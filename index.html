<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Minion Solitaire</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    
    <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #2c3e50; font-family: sans-serif; user-select: none; }
        
        #ui-container {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            text-align: center; color: #fce029; text-shadow: 1px 1px 2px #000;
            pointer-events: none; 
            z-index: 10;
            width: 90%;
            max-width: 600px;
        }
        
        h1 { margin: 5px 0; font-size: 1.5rem; }
        
        #controls {
            pointer-events: auto;
            background: rgba(0,0,0,0.6); padding: 10px 15px; border-radius: 15px;
            display: inline-block; border: 2px solid #4a90e2; margin-top: 5px;
        }
        
        button {
            padding: 8px 12px; font-size: 0.9rem; cursor: pointer; border: none; border-radius: 20px;
            background-color: #4a90e2; color: #fce029; font-weight: bold; margin: 0 3px; transition: all 0.2s;
        }
        button:hover { background-color: #fce029; color: #4a90e2; transform: scale(1.05); }
        button:active { transform: scale(0.95); }
        button:disabled { background-color: #7f8c8d; color: #bdc3c7; cursor: not-allowed; transform: none; }
        
        #status-text { 
            margin-top: 10px; font-family: monospace; font-size: 1rem; 
            background: rgba(0,0,0,0.4); display: inline-block; padding: 2px 8px; border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1>3D Minion Solitaire</h1>
        <div id="controls">
            <button id="btn-play">â–¶ Auto Play</button>
            <button id="btn-step">Step >></button>
            <button id="btn-reset">Reset</button>
            <button id="btn-sound" onclick="toggleMute()">ðŸ”Š On</button>
        </div>
        <br>
        <div id="status-text">Initializing 3D World...</div>
    </div>

<script>
    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let isMuted = false;

    function unlockAudio() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playKickSound() {
        if (isMuted) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.15);
        gain.gain.setValueAtTime(1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        osc.start(t);
        osc.stop(t + 0.15);
    }

    function playScreamSound() {
        if (isMuted) return;
        const t = audioCtx.currentTime;
        const carrier = audioCtx.createOscillator();
        const carrierGain = audioCtx.createGain();
        const modulator = audioCtx.createOscillator();
        const modulatorGain = audioCtx.createGain();
        modulator.connect(modulatorGain);
        modulatorGain.connect(carrier.frequency);
        carrier.connect(carrierGain);
        carrierGain.connect(audioCtx.destination);
        carrier.type = 'sawtooth'; 
        carrier.frequency.setValueAtTime(800, t); 
        carrier.frequency.exponentialRampToValueAtTime(200, t + 2.0);
        modulator.frequency.value = 15; 
        modulatorGain.gain.setValueAtTime(50, t); 
        carrierGain.gain.setValueAtTime(0.2, t);
        carrierGain.gain.linearRampToValueAtTime(0, t + 2.0);
        carrier.start(t); carrier.stop(t + 2.0);
        modulator.start(t); modulator.stop(t + 2.0);
    }

    function toggleMute() {
        isMuted = !isMuted;
        document.getElementById('btn-sound').innerText = isMuted ? "ðŸ”‡ Off" : "ðŸ”Š On";
        unlockAudio();
    }

    // --- GAME LOGIC ---
    const N = 7;
    const TILE_SIZE = 2; 
    const BOARD_OFFSET = (N * TILE_SIZE) / 2 - (TILE_SIZE / 2);
    
    let initialBoard = [
        [-1,-1, 1, 1, 1,-1,-1],
        [-1,-1, 1, 1, 1,-1,-1],
        [ 1, 1, 1, 1, 1, 1, 1],
        [ 1, 1, 1, 0, 1, 1, 1],
        [ 1, 1, 1, 1, 1, 1, 1],
        [-1,-1, 1, 1, 1,-1,-1],
        [-1,-1, 1, 1, 1,-1,-1]
    ];

    let boardState = [];
    let solutionMoves = [];
    let currentMoveIndex = 0;
    let isAnimating = false;
    let isAutoPlaying = false;
    let scene, camera, renderer, controls;
    let minionMap = new Map(); 

    function solveGame() {
        let solverBoard = JSON.parse(JSON.stringify(initialBoard));
        let moves = [];
        function backtrack(pegsLeft) {
            if (pegsLeft === 1) return solverBoard[3][3] === 1;
            const dr = [1, 0, -1, 0]; const dc = [0, 1, 0, -1];
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    if (solverBoard[r][c] !== 1) continue;
                    for (let i = 0; i < 4; i++) {
                        let mid_r = r + dr[i]; let mid_c = c + dc[i];
                        let to_r = r + 2 * dr[i]; let to_c = c + 2 * dc[i];
                        if (to_r < 0 || to_r >= N || to_c < 0 || to_c >= N) continue;
                        if (solverBoard[mid_r][mid_c] === 1 && solverBoard[to_r][to_c] === 0) {
                            solverBoard[r][c] = 0; solverBoard[mid_r][mid_c] = 0; solverBoard[to_r][to_c] = 1;
                            moves.push({from: {r, c}, removed: {r: mid_r, c: mid_c}, to: {r: to_r, c: to_c}});
                            if (backtrack(pegsLeft - 1)) return true;
                            moves.pop(); solverBoard[r][c] = 1; solverBoard[mid_r][mid_c] = 1; solverBoard[to_r][to_c] = 0;
                        }
                    }
                }
            }
            return false;
        }
        backtrack(32);
        return moves;
    }

    function init3D() {
        if (typeof THREE === 'undefined') { setTimeout(init3D, 100); return; }
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2c3e50);
        scene.fog = new THREE.Fog(0x2c3e50, 20, 50);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 14, 12); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7.5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        if (typeof THREE.OrbitControls !== 'undefined') {
             controls = new THREE.OrbitControls(camera, renderer.domElement);
             controls.enableDamping = true; 
        }

        createBoardEnvironment();
        window.addEventListener('resize', onWindowResize, false);
        animateLoop();
    }

    function createBoardEnvironment() {
        const floorGeo = new THREE.PlaneGeometry(60, 60);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a252f, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2; floor.position.y = -0.5; floor.receiveShadow = true;
        scene.add(floor);

        const boardGeo = new THREE.BoxGeometry(N*TILE_SIZE + 1, 0.5, N*TILE_SIZE + 1);
        const boardMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.6 });
        const board = new THREE.Mesh(boardGeo, boardMat);
        board.position.y = -0.25; board.receiveShadow = true;
        scene.add(board);

        const holeGeo = new THREE.CircleGeometry(TILE_SIZE * 0.3, 32);
        const holeMat = new THREE.MeshStandardMaterial({ color: 0x2c1b15, roughness: 1 });
        
        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                if (initialBoard[r][c] !== -1) {
                    const hole = new THREE.Mesh(holeGeo, holeMat);
                    hole.rotation.x = -Math.PI / 2;
                    const pos = gridToWorld(r, c);
                    hole.position.set(pos.x, 0.01, pos.z); 
                    scene.add(hole);
                }
            }
        }
    }

    // --- UPDATED MINION MODEL (Longer legs, angled arms) ---
    function createMinionMesh() {
        const group = new THREE.Group();
        group.userData.limbs = {}; 

        // 1. MAIN BODY
        const bodyGeo = new THREE.CapsuleGeometry(0.6, 0.6, 4, 16); 
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xfce029, roughness: 0.4 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1;
        body.castShadow = true; 
        group.add(body);

        // 2. PANTS
        const pantsGeo = new THREE.SphereGeometry(0.65, 32, 32, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
        const pantsMat = new THREE.MeshStandardMaterial({ color: 0x4a90e2, roughness: 0.6 });
        const pants = new THREE.Mesh(pantsGeo, pantsMat);
        pants.rotation.x = Math.PI; pants.position.y = 0.65;
        group.add(pants);

        // 3. EYES & GOGGLES
        const eyeGeo = new THREE.SphereGeometry(0.25, 32, 32);
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.set(0, 1.3, 0.48);
        const pupilGeo = new THREE.SphereGeometry(0.1, 16, 16);
        const pupilMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 });
        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
        pupil.position.set(0, 0, 0.22);
        eye.add(pupil);
        const goggleFrameGeo = new THREE.TorusGeometry(0.25, 0.05, 8, 24);
        const goggleMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
        const goggle = new THREE.Mesh(goggleFrameGeo, goggleMat);
        goggle.position.set(0, 1.3, 0.48);
        group.add(eye); group.add(goggle);

        // 4. ARMS (Pivots at shoulder)
        const armGeo = new THREE.CapsuleGeometry(0.12, 0.5, 4, 8);
        const gloveGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const gloveMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        function createArm(isLeft) {
            const pivot = new THREE.Group();
            const xOffset = isLeft ? -0.65 : 0.65;
            pivot.position.set(xOffset, 1.1, 0); 
            const armMesh = new THREE.Mesh(armGeo, bodyMat);
            armMesh.position.y = -0.25; 
            const glove = new THREE.Mesh(gloveGeo, gloveMat);
            glove.position.y = -0.35;
            armMesh.add(glove);
            pivot.add(armMesh);
            // UPDATE: Increased outward angle for natural pose
            pivot.rotation.z = isLeft ? -0.5 : 0.5; 
            return pivot;
        }

        const leftArm = createArm(true);
        const rightArm = createArm(false);
        group.add(leftArm); group.add(rightArm);
        group.userData.limbs.leftArm = leftArm; group.userData.limbs.rightArm = rightArm;

        // 5. LEGS & FEET (Pivots at hip)
        // UPDATE: Longer leg geometry (0.3 -> 0.6)
        const legGeo = new THREE.CapsuleGeometry(0.12, 0.6, 4, 8);
        const bootGeo = new THREE.BoxGeometry(0.25, 0.2, 0.35);
        const bootMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        function createLeg(isLeft) {
            const pivot = new THREE.Group();
            const xOffset = isLeft ? -0.25 : 0.25;
            // UPDATE: Raised hip pivot slightly
            pivot.position.set(xOffset, 0.6, 0); 

            const legMesh = new THREE.Mesh(legGeo, pantsMat);
            // UPDATE: Adjusted offset for longer leg
            legMesh.position.y = -0.35; 

            const boot = new THREE.Mesh(bootGeo, bootMat);
            // UPDATE: Adjusted boot offset
            boot.position.y = -0.35;
            boot.position.z = 0.1; 
            legMesh.add(boot);

            pivot.add(legMesh);
            return pivot;
        }

        const leftLeg = createLeg(true);
        const rightLeg = createLeg(false);
        group.add(leftLeg); group.add(rightLeg);
        group.userData.limbs.leftLeg = leftLeg; group.userData.limbs.rightLeg = rightLeg;

        group.scale.set(0.8, 0.8, 0.8);
        return group;
    }

    function gridToWorld(r, c) {
        return { x: (c * TILE_SIZE) - BOARD_OFFSET, z: (r * TILE_SIZE) - BOARD_OFFSET };
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animateLoop() {
        requestAnimationFrame(animateLoop);
        if (controls) controls.update(); 
        renderer.render(scene, camera);
    }

    async function initGame() {
        if (typeof THREE === 'undefined') { setTimeout(initGame, 100); return; }
        init3D();
        document.getElementById('status-text').innerText = "Calculating solution...";
        await new Promise(resolve => setTimeout(resolve, 50));
        solutionMoves = solveGame();
        document.getElementById('status-text').innerText = `Ready. Solution: ${solutionMoves.length} moves.`;
        resetBoard();
        setupEventListeners();
    }

    function resetBoard() {
        stopAutoPlay();
        if (isAnimating) return; 
        currentMoveIndex = 0;
        boardState = JSON.parse(JSON.stringify(initialBoard));
        minionMap.forEach(mesh => scene.remove(mesh));
        minionMap.clear();
        for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
                if (boardState[r][c] === 1) {
                    const minionMesh = createMinionMesh();
                    const pos = gridToWorld(r, c);
                    minionMesh.position.set(pos.x, 0, pos.z);
                    scene.add(minionMesh);
                    minionMap.set(`${r},${c}`, minionMesh);
                }
            }
        }
        updateUI();
    }

    // --- ANIMATION HELPERS ---
    function animateWalkCycle(minion, duration) {
        const limbs = minion.userData.limbs;
        const speed = 0.2; 
        const repeats = Math.floor(duration / speed);
        limbs.leftLeg.rotation.x = 0; limbs.rightLeg.rotation.x = 0;
        limbs.leftArm.rotation.x = 0; limbs.rightArm.rotation.x = 0;
        const tl = gsap.timeline();
        tl.to([limbs.leftLeg.rotation, limbs.rightArm.rotation], {
            x: 0.8, duration: speed, ease: "sine.inOut", yoyo: true, repeat: repeats
        }, 0);
        tl.to([limbs.rightLeg.rotation, limbs.leftArm.rotation], {
            x: -0.8, duration: speed, ease: "sine.inOut", yoyo: true, repeat: repeats
        }, 0);
        tl.to(minion.position, {
            y: minion.position.y + 0.15, duration: speed/2, ease: "sine.inOut", yoyo: true, repeat: repeats * 2
        }, 0);
        return tl;
    }

    function animateKick(minion) {
        const limbs = minion.userData.limbs;
        const tl = gsap.timeline();
        tl.to(limbs.rightLeg.rotation, { x: -1.5, duration: 0.1, ease: "power2.out" });
        tl.to(limbs.rightLeg.rotation, { x: 0, duration: 0.2, ease: "power2.in" });
        return tl;
    }

    function performDramaticMove(move) {
        return new Promise((resolve) => {
            isAnimating = true;
            unlockAudio();
            updateUI();

            const actingMesh = minionMap.get(`${move.from.r},${move.from.c}`);
            const kickedMesh = minionMap.get(`${move.removed.r},${move.removed.c}`);
            const targetPos = gridToWorld(move.to.r, move.to.c);
            const midPos = gridToWorld(move.removed.r, move.removed.c);
            const kickDirX = move.removed.c - move.from.c;
            const kickDirZ = move.removed.r - move.from.r;

            actingMesh.lookAt(targetPos.x, actingMesh.position.y, targetPos.z);
            
            const mainTl = gsap.timeline({
                onComplete: () => {
                    scene.remove(kickedMesh);
                    minionMap.delete(`${move.from.r},${move.from.c}`);
                    minionMap.delete(`${move.removed.r},${move.removed.c}`);
                    minionMap.set(`${move.to.r},${move.to.c}`, actingMesh);
                    boardState[move.from.r][move.from.c] = 0;
                    boardState[move.removed.r][move.removed.c] = 0;
                    boardState[move.to.r][move.to.c] = 1;
                    currentMoveIndex++;
                    isAnimating = false;
                    updateUI();
                    resolve();
                }
            });

            const approachDuration = 1.0;
            mainTl.addLabel("startApproach");
            mainTl.to(actingMesh.position, { x: midPos.x, z: midPos.z, duration: approachDuration, ease: "linear" }, "startApproach");
            mainTl.add(animateWalkCycle(actingMesh, approachDuration), "startApproach");

            const kickTime = "startApproach+=" + approachDuration;
            mainTl.addLabel("kick", kickTime);
            mainTl.to(actingMesh.position, { 
                x: midPos.x + kickDirX*0.3, z: midPos.z + kickDirZ*0.3, duration: 0.15, ease: "back.out(2)",
                onStart: () => { playKickSound(); }
            }, "kick");
            mainTl.add(animateKick(actingMesh), "kick");

            mainTl.to(kickedMesh.position, {
                x: midPos.x + kickDirX * 12, y: 15, z: midPos.z + kickDirZ * 12,
                duration: 2.5, ease: "power2.out", onStart: () => { playScreamSound(); }
            }, "kick"); 
            mainTl.to(kickedMesh.rotation, { x: Math.PI*4, z: Math.PI*2, duration: 2.5, ease: "none" }, "kick");
            mainTl.to(kickedMesh.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 0.5 }, "kick+=2.0");

            const walkBackTime = "kick+=0.5"; 
            const finishDuration = 0.8;
            mainTl.to(actingMesh.position, { x: targetPos.x, z: targetPos.z, duration: finishDuration, ease: "linear" }, walkBackTime);
            mainTl.add(animateWalkCycle(actingMesh, finishDuration), walkBackTime);
        });
    }

    async function stepForward() {
        if (isAnimating || currentMoveIndex >= solutionMoves.length) return;
        await performDramaticMove(solutionMoves[currentMoveIndex]);
        if (currentMoveIndex >= solutionMoves.length) finishGame();
    }

    async function autoPlayLoop() {
        while (isAutoPlaying && currentMoveIndex < solutionMoves.length) {
            await performDramaticMove(solutionMoves[currentMoveIndex]);
            if(isAutoPlaying && currentMoveIndex < solutionMoves.length) await new Promise(r => setTimeout(r, 200));
        }
        if (currentMoveIndex >= solutionMoves.length) finishGame();
        stopAutoPlay();
    }

    function startAutoPlay() {
        if (currentMoveIndex >= solutionMoves.length) resetBoard();
        if (isAnimating) return;
        isAutoPlaying = true;
        updateUI();
        autoPlayLoop();
    }

    function stopAutoPlay() { isAutoPlaying = false; updateUI(); }
    function finishGame() { document.getElementById('status-text').innerText = "Victory!"; stopAutoPlay(); }

    function updateUI() {
        const btnPlay = document.getElementById('btn-play');
        const btnStep = document.getElementById('btn-step');
        const btnReset = document.getElementById('btn-reset');
        const status = document.getElementById('status-text');
        btnPlay.innerText = isAutoPlaying ? "âšâš Pause" : "â–¶ Auto Play";
        const locked = isAnimating || currentMoveIndex >= solutionMoves.length;
        btnStep.disabled = locked || isAutoPlaying;
        btnPlay.disabled = locked && !isAutoPlaying;
        btnReset.disabled = isAnimating;
        if (currentMoveIndex < solutionMoves.length) status.innerText = `Moves: ${currentMoveIndex} / ${solutionMoves.length}`;
    }

    function setupEventListeners() {
        document.getElementById('btn-play').addEventListener('click', () => isAutoPlaying ? stopAutoPlay() : startAutoPlay());
        document.getElementById('btn-step').addEventListener('click', stepForward);
        document.getElementById('btn-reset').addEventListener('click', resetBoard);
    }

    initGame();
</script>
</body>
</html>